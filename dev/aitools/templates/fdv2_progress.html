<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Parsing…</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 18px; }
    .bar { width: 100%; background: #eee; height: 12px; border-radius: 6px; overflow: hidden; }
    .bar > div { height: 100%; background: #4caf50; width: 0%; transition: width 0.3s; }
    .small { color: #555; font-size: 12px; }
    .mono { font-family: Consolas, monospace; }
  </style>
</head>
<body>
  <h3>Parsing FDV logs…</h3>
  <div class="small" style="margin:4px 0 10px 0; background:#f4f8ff; padding:6px 8px; border-left:4px solid #3a78c2;">
    {% if job_id %}<div>Job ID: <span class="mono" id="jobIdDisp">{{ job_id }}</span></div>{% endif %}
    <div>Token: <span class="mono" id="tokenDisp">{{ token }}</span></div>
    <div style="margin-top:4px;">
      <a href="/job/{{ job_id }}/status" target="_blank" rel="noopener" class="small">JSON Status</a>
      {% if job_id %} &middot; <a href="/job/{{ job_id }}/report" target="_blank" rel="noopener" class="small">Open Report (new tab)</a>{% endif %}
    </div>
  </div>
  <div class="bar"><div id="fill"></div></div>
  <div class="small mono" id="txt">Starting…</div>
  <div class="small mono" id="eta" style="margin-top:2px;color:#666;"></div>
  {% if prodmode %}
  <div style="margin:8px 0;">
    <button id="doneBtn" type="button" onclick="return onDone();">Done</button>
    <span class="small" style="margin-left:6px;color:#444;">Click 'Done' to stop after the current file and generate the report.</span>
  </div>
  {% endif %}
  <div class="small" style="margin-top:4px;">
    <span id="overall_total_lines" class="mono"></span>
    <span id="current_file_total_lines" class="mono" style="margin-left:12px;"></span>
    <span id="expected_lines_info" class="mono" style="margin-left:12px;color:#444;"></span>
  </div>
  <div class="small" id="currwrap" style="margin-top:6px;">
    <strong>Current file:</strong>
    <span id="curr" class="mono" title=""></span>
  <span id="currpct" class="small mono" style="margin-left:6px;color:#777;"></span>
  <!-- per-file ETA now shown in unified ETA line above -->
  </div>
  <h4 style="margin-top:14px;">FDV tests seen so far</h4>
  <div class="small" style="margin:4px 0 8px 0;">
    <label for="limitProgress">RBER limit:</label>
  <input type="text" id="limitProgress" size="8" placeholder="default" />
    <button type="button" onclick="return applyProgressLimit();">Apply</button>
    <span id="limitMode" style="margin-left:6px;color:#444;"></span>
  </div>
  <div id="fdvtable" class="small">Collecting…</div>
  <script data-limit="{{ limit_raw or '' }}" data-prodm="{{ '1' if prodmode else '0' }}">
  const token = "{{ token }}";
  const jobId = "{{ job_id or '' }}";
  const prodmode = (document.currentScript.getAttribute('data-prodm') === '1');
  // RBER limit chosen when analysis started; blank/none => token (log PASS/FAIL) mode
  let limitRaw = (document.currentScript.getAttribute('data-limit') || '').trim();
  function updateLimitModeDisplay(){
    try {
      const m = document.getElementById('limitMode');
      if (!m) return;
  if (!limitRaw || ['none','default'].includes(limitRaw.toLowerCase())) {
        m.textContent = 'Mode: using PASS/FAIL flags from logs.';
      } else {
        m.textContent = 'Mode: threshold by RBER limit ' + limitRaw + '.';
      }
    } catch(e){}
  }
  function applyProgressLimit(){
    try {
      const inp = document.getElementById('limitProgress');
      if (!inp) return false;
      let v = (inp.value || '').trim();
  if (['none','default'].includes(v.toLowerCase())) v = '';
      limitRaw = v; // update global used by refreshTable
      // Persist in localStorage + cookie similar to main page for continuity
      try { localStorage.setItem('fdv2_limit', v); } catch(e){}
      try { document.cookie = 'fdv2_limit=' + encodeURIComponent(v) + '; path=/; max-age=31536000; SameSite=Lax'; } catch(e){}
      updateLimitModeDisplay();
      // Force immediate table refresh with new limit
      try { refreshTable(true); } catch(e){}
    } catch(e){}
    return false;
  }
    let lastLines = 0;
    let lastPercent = 0;
    let lastTableHtml = '';
    let startTimeMs = null; // wall-clock when first measurable progress observed
  let lastEtaSeconds = null; // smoothing for overall ETA
  let lastFileEtaSeconds = null; // smoothing for per-file ETA
  let fileEtaDisplay = '';
  function fmtEta(sec) {
      if (sec == null || !isFinite(sec) || sec < 0) return '';
      const s = Math.round(sec);
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const r = s % 60;
      if (h > 0) return `${h}h ${m}m ${r}s`; if (m > 0) return `${m}m ${r}s`; return `${r}s`;
    }
  // Per-file ETA tracking
  let currentFilePath = null;
  let currentFileStartTimeMs = null;
  let currentFileStartLines = 0;
  let currentFileStartBytes = 0;
    let sseActive = false;
    function startSSE(){
      if (!jobId) return false;
      try {
        const es = new EventSource(`/stream/job/${jobId}`);
        sseActive = true;
        es.onmessage = (evt)=>{
          try {
            const data = JSON.parse(evt.data || '{}');
            applyProgressData(data);
            if (data.status === 'done' || data.status === 'error') {
              es.close();
            }
          } catch(e){}
        };
        es.onerror = ()=>{ try { es.close(); } catch(_){}; sseActive = false; poll(); };
        return true;
      } catch(e){ sseActive = false; return false; }
    }
    function applyProgressData(data){
      const st = data.status || 'unknown';
      const p = data.progress || {};
      // Prefer server-provided overall ETA if available (seconds)
      let serverEta = null;
      try {
        if (p.eta_overall_secs != null && isFinite(p.eta_overall_secs) && Number(p.eta_overall_secs) > 0) {
          serverEta = Number(p.eta_overall_secs);
        } else if (data.eta_overall_secs != null && isFinite(data.eta_overall_secs) && Number(data.eta_overall_secs) > 0) {
          serverEta = Number(data.eta_overall_secs);
        }
      } catch(_){}
      const percent = Math.max(0, Math.min(100, Number(p.percent || 0)));
      const lines = Number(p.lines || 0);
      const linesTotal = Number(p.lines_total || 0);
  const expectedOverall = Number(p.expected_overall_lines || linesTotal || 0);
      const fileLinesDone = Number(p.file_lines_done || 0);
      const fileLinesTotal = Number(p.file_lines_total || 0);
  const expectedFile = Number(p.expected_file_lines || fileLinesTotal || 0);
      const filePercent = Math.max(0, Math.min(100, Number(p.file_percent || 0)));
      const filesDone = p.files_done || 0;
      const filesTotal = p.files_total || 0;
      const curr = p.current_file || '';
      document.getElementById('fill').style.width = percent.toFixed(1) + '%';
      const totalLineStr = linesTotal ? ` / ${linesTotal.toLocaleString()} lines` : '';
      // Build unified progress line per requested format:
      // 100.0% — overall CUR / TOTAL lines — files X/Y | file A / B lines (P%)
      let overallTxt = '';
      if (linesTotal > 0) {
        overallTxt = `${percent.toFixed(1)}% — overall ${lines.toLocaleString()} / ${linesTotal.toLocaleString()} lines — files ${filesDone}/${filesTotal}`;
      } else {
        // Fallback when total unknown
        overallTxt = `${percent.toFixed(1)}% — overall ${lines.toLocaleString()} lines — files ${filesDone}/${filesTotal}`;
      }
      if (fileLinesTotal > 0) {
        overallTxt += ` | file ${fileLinesDone.toLocaleString()} / ${fileLinesTotal.toLocaleString()} lines (${filePercent.toFixed(1)}%)`;
      } else {
        overallTxt += ` | file ${fileLinesDone.toLocaleString()} lines`;
      }
      document.getElementById('txt').textContent = overallTxt;
      const el = document.getElementById('curr');
      if (el){ const base = curr.replaceAll('\\\\','/'); const name = base.includes('/') ? base.split('/').pop() : base; el.textContent = name || '(preparing…)'; el.title = curr || ''; }
      const ep = document.getElementById('currpct'); if (ep) ep.textContent = filePercent ? `(${filePercent.toFixed(1)}%)` : '';

      // Establish overall start time when first progress observed
      try {
        if ((percent > 0 || lines > 0) && startTimeMs == null) {
          startTimeMs = Date.now();
        }
      } catch(_){ }

      // Update separate total line indicators
      try {
        const ot = document.getElementById('overall_total_lines');
        if (ot) {
          if (linesTotal > 0) {
            ot.textContent = `overall: ${lines.toLocaleString()} / ${linesTotal.toLocaleString()} lines (${percent.toFixed(1)}%)`;
          } else if (lines > 0) {
            ot.textContent = `overall: ${lines.toLocaleString()} lines`;
          } else {
            ot.textContent = '';
          }
        }
        const cft = document.getElementById('current_file_total_lines');
        if (cft) {
          if (fileLinesTotal > 0) {
            cft.textContent = `current file total: ${fileLinesDone.toLocaleString()} / ${fileLinesTotal.toLocaleString()} lines (${filePercent.toFixed(1)}%)`;
          } else if (fileLinesDone > 0) {
            cft.textContent = `current file: ${fileLinesDone.toLocaleString()} lines`;
          } else {
            cft.textContent = '';
          }
        }
        const ei = document.getElementById('expected_lines_info');
        if (ei) {
          if (expectedOverall > 0 || expectedFile > 0) {
            const parts = [];
            if (expectedOverall > 0) parts.push(`expected overall: ${expectedOverall.toLocaleString()}`);
            if (expectedFile > 0) parts.push(`expected file: ${expectedFile.toLocaleString()}`);
            ei.textContent = parts.join(' | ');
          } else {
            ei.textContent = '';
          }
        }
      } catch(_){ }

      // Compute overall ETA
      let overallEtaTxt = '';
      try {
        if (serverEta != null) {
          // Light smoothing client-side too, using last server ETA
          let rem = serverEta;
          if (lastEtaSeconds != null) rem = 0.5 * rem + 0.5 * lastEtaSeconds;
          lastEtaSeconds = rem;
          overallEtaTxt = 'overall ETA ' + fmtEta(rem);
        } else if (startTimeMs != null) {
          const elapsedSec = (Date.now() - startTimeMs) / 1000.0;
          let remainingSec = null;
          if (linesTotal > 0 && lines > 0) {
            const rate = lines / elapsedSec;
            if (rate > 0) remainingSec = (linesTotal - lines) / rate;
          } else if (percent > 0) {
            const rateP = percent / elapsedSec;
            if (rateP > 0) remainingSec = (100 - percent) / rateP;
          }
          if (remainingSec != null) {
            if (lastEtaSeconds != null) remainingSec = 0.5 * remainingSec + 0.5 * lastEtaSeconds;
            lastEtaSeconds = remainingSec;
            overallEtaTxt = 'overall ETA ' + fmtEta(remainingSec);
          }
        }
      } catch(_){ }

      // Per-file ETA handling
      try {
        const baseCurr = curr || '';
        if (baseCurr && baseCurr !== currentFilePath) {
          currentFilePath = baseCurr;
            currentFileStartTimeMs = Date.now();
          currentFileStartLines = fileLinesDone;
          currentFileStartBytes = Number(p.file_bytes_done || 0);
          lastFileEtaSeconds = null;
        }
        let fileEtaTxt = '';
        if (currentFileStartTimeMs != null && filePercent > 0 && (fileLinesTotal > 0 || Number(p.file_bytes_total||0) > 0)) {
          const elapsedFileSec = (Date.now() - currentFileStartTimeMs) / 1000.0;
          let remainingFileSec = null;
          if (fileLinesTotal > 0 && fileLinesDone > currentFileStartLines) {
            const processed = fileLinesDone - currentFileStartLines;
            const rate = processed / elapsedFileSec;
            if (rate > 0) remainingFileSec = (fileLinesTotal - fileLinesDone) / rate;
          } else {
            const fbTotal = Number(p.file_bytes_total || 0);
            const fbDone = Number(p.file_bytes_done || 0);
            if (fbTotal > 0 && fbDone > currentFileStartBytes) {
              const processedB = fbDone - currentFileStartBytes;
              const rateB = processedB / elapsedFileSec;
              if (rateB > 0) remainingFileSec = (fbTotal - fbDone) / rateB;
            }
          }
          if (remainingFileSec != null) {
            if (lastFileEtaSeconds != null) remainingFileSec = 0.5 * remainingFileSec + 0.5 * lastFileEtaSeconds;
            lastFileEtaSeconds = remainingFileSec;
            fileEtaTxt = 'file ETA ' + fmtEta(remainingFileSec);
          }
        }
        fileEtaDisplay = fileEtaTxt;
      } catch(_){ }

      // Update unified ETA line
      try {
        const etaEl = document.getElementById('eta');
        if (etaEl) {
          const parts = [];
          if (overallEtaTxt) parts.push(overallEtaTxt);
          if (fileEtaDisplay) parts.push(fileEtaDisplay);
          etaEl.textContent = parts.join(' | ');
        }
      } catch(_){ }

      if (st === 'done') {
        const limParam = encodeURIComponent(limitRaw);
        const limPart = `&limit=${limParam}`;
        window.location.href = `{{ url_for('report_home') }}?token=${token}` + (limitRaw !== '' ? limPart : '&limit=none');
        return;
      }
      if (st === 'error') { document.getElementById('txt').textContent = 'Error: ' + (data.error || 'unknown'); }
    }
    async function poll() {
      if (sseActive) return; // SSE supersedes polling
      try {
        const res = await fetch(`{{ url_for('report_status', token='__TOK__') }}`.replace('__TOK__', token), {cache: 'no-store'});
        if (!res.ok) throw new Error('status ' + res.status);
        const data = await res.json();
        applyProgressData(data);
        // If not finished, schedule next poll
        if (!(data && (data.status === 'done' || data.status === 'error'))) {
          setTimeout(poll, 800);
        }
        return;
      } catch (e) {
        // transient errors are okay; keep polling
      }
      setTimeout(poll, 800);
    }
    async function onDone(){
      try {
        if (!prodmode) return false;
        const btn = document.getElementById('doneBtn'); if (btn){ btn.disabled = true; btn.textContent = 'Finishing…'; }
        const res = await fetch(`/api/job/${jobId}/done`, {method: 'POST'});
        if (res.ok) {
          const data = await res.json();
          const url = data && data.report_url ? data.report_url : `/job/${jobId}/report`;
          window.location.href = url;
        } else {
          if (btn){ btn.disabled = false; btn.textContent = 'Done'; }
        }
      } catch(e){ const btn = document.getElementById('doneBtn'); if (btn){ btn.disabled = false; btn.textContent = 'Done'; } }
      return false;
    }
  async function refreshTable(forceImmediate=false) {
      try {
    const bust = Date.now();
  const baseUrl = `{{ url_for('report_status_fdvtable', token='__TOK__') }}`.replace('__TOK__', token);
  // Include limit parameter so interim PASS/FAIL reflects selected mode
  const limQ = (limitRaw && limitRaw.toLowerCase() !== 'none') ? `&limit=${encodeURIComponent(limitRaw)}` : '&limit=none';
  const res = await fetch(baseUrl + `?t=${bust}` + limQ, {cache: 'no-store'});
        if (res.ok) {
          const html = await res.text();
          if (html && html !== lastTableHtml) {
            document.getElementById('fdvtable').innerHTML = html;
            lastTableHtml = html;
          }
        }
      } catch (e) { /* ignore */ }
      if (!forceImmediate) setTimeout(refreshTable, 1500);
    }
  if (!startSSE()) { poll(); }
    refreshTable();
    // Initialize limit input & mode display
  (function initLimitBox(){ try { const inp = document.getElementById('limitProgress'); if (inp) { inp.value = (limitRaw || 'default'); } updateLimitModeDisplay(); } catch(e){} })();
  </script>
</body>
</html>
