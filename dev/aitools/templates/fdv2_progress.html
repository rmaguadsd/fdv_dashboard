<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Parsing…</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 18px; }
    .bar { width: 100%; background: #eee; height: 12px; border-radius: 6px; overflow: hidden; }
    .bar > div { height: 100%; background: #4caf50; width: 0%; transition: width 0.3s; }
    .small { color: #555; font-size: 12px; }
    .mono { font-family: Consolas, monospace; }
  </style>
</head>
<body>
  <h3>Parsing FDV logs…</h3>
  <div class="small" style="margin:4px 0 10px 0; background:#f4f8ff; padding:6px 8px; border-left:4px solid #3a78c2;">
    {% if job_id %}<div>Job ID: <span class="mono" id="jobIdDisp">{{ job_id }}</span></div>{% endif %}
    <div>Token: <span class="mono" id="tokenDisp">{{ token }}</span></div>
    <div style="margin-top:4px;">
      <a href="/job/{{ job_id }}/status" target="_blank" rel="noopener" class="small">JSON Status</a>
      {% if job_id %} &middot; <a href="/job/{{ job_id }}/report" target="_blank" rel="noopener" class="small">Open Report (new tab)</a>{% endif %}
    </div>
  </div>
  <div class="bar"><div id="fill"></div></div>
  <div class="small mono" id="txt">Starting…</div>
  <div class="small mono" id="eta" style="margin-top:2px;color:#666;"></div>
  <div class="small" style="margin-top:4px;">
    <span id="overall_total_lines" class="mono"></span>
    <span id="current_file_total_lines" class="mono" style="margin-left:12px;"></span>
  </div>
  <div class="small" id="currwrap" style="margin-top:6px;">
    <strong>Current file:</strong>
    <span id="curr" class="mono" title=""></span>
  <span id="currpct" class="small mono" style="margin-left:6px;color:#777;"></span>
  <!-- per-file ETA now shown in unified ETA line above -->
  </div>
  <h4 style="margin-top:14px;">FDV tests seen so far</h4>
  <div class="small" style="margin:4px 0 8px 0;">
    <label for="limitProgress">RBER limit:</label>
  <input type="text" id="limitProgress" size="8" placeholder="default" />
    <button type="button" onclick="return applyProgressLimit();">Apply</button>
    <span id="limitMode" style="margin-left:6px;color:#444;"></span>
  </div>
  <div id="fdvtable" class="small">Collecting…</div>
  <script data-limit="{{ limit_raw or '' }}">
  const token = "{{ token }}";
  const jobId = "{{ job_id or '' }}";
  // RBER limit chosen when analysis started; blank/none => token (log PASS/FAIL) mode
  let limitRaw = (document.currentScript.getAttribute('data-limit') || '').trim();
  function updateLimitModeDisplay(){
    try {
      const m = document.getElementById('limitMode');
      if (!m) return;
  if (!limitRaw || ['none','default'].includes(limitRaw.toLowerCase())) {
        m.textContent = 'Mode: using PASS/FAIL flags from logs.';
      } else {
        m.textContent = 'Mode: threshold by RBER limit ' + limitRaw + '.';
      }
    } catch(e){}
  }
  function applyProgressLimit(){
    try {
      const inp = document.getElementById('limitProgress');
      if (!inp) return false;
      let v = (inp.value || '').trim();
  if (['none','default'].includes(v.toLowerCase())) v = '';
      limitRaw = v; // update global used by refreshTable
      // Persist in localStorage + cookie similar to main page for continuity
      try { localStorage.setItem('fdv2_limit', v); } catch(e){}
      try { document.cookie = 'fdv2_limit=' + encodeURIComponent(v) + '; path=/; max-age=31536000; SameSite=Lax'; } catch(e){}
      updateLimitModeDisplay();
      // Force immediate table refresh with new limit
      try { refreshTable(true); } catch(e){}
    } catch(e){}
    return false;
  }
    let lastLines = 0;
    let lastPercent = 0;
    let lastTableHtml = '';
    let startTimeMs = null; // wall-clock when first measurable progress observed
  let lastEtaSeconds = null; // smoothing for overall ETA
  let lastFileEtaSeconds = null; // smoothing for per-file ETA
  let fileEtaDisplay = '';
  function fmtEta(sec) {
      if (sec == null || !isFinite(sec) || sec < 0) return '';
      const s = Math.round(sec);
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const r = s % 60;
      if (h > 0) return `${h}h ${m}m ${r}s`; if (m > 0) return `${m}m ${r}s`; return `${r}s`;
    }
  // Per-file ETA tracking
  let currentFilePath = null;
  let currentFileStartTimeMs = null;
  let currentFileStartLines = 0;
  let currentFileStartBytes = 0;
    let sseActive = false;
    function startSSE(){
      if (!jobId) return false;
      try {
        const es = new EventSource(`/stream/job/${jobId}`);
        sseActive = true;
        es.onmessage = (evt)=>{
          try {
            const data = JSON.parse(evt.data || '{}');
            applyProgressData(data);
            if (data.status === 'done' || data.status === 'error') {
              es.close();
            }
          } catch(e){}
        };
        es.onerror = ()=>{ try { es.close(); } catch(_){}; sseActive = false; poll(); };
        return true;
      } catch(e){ sseActive = false; return false; }
    }
    function applyProgressData(data){
      const st = data.status || 'unknown';
      const p = data.progress || {};
      const percent = Math.max(0, Math.min(100, Number(p.percent || 0)));
      const lines = Number(p.lines || 0);
      const linesTotal = Number(p.lines_total || 0);
      const fileLinesDone = Number(p.file_lines_done || 0);
      const fileLinesTotal = Number(p.file_lines_total || 0);
      const filePercent = Math.max(0, Math.min(100, Number(p.file_percent || 0)));
      const filesDone = p.files_done || 0;
      const filesTotal = p.files_total || 0;
      const curr = p.current_file || '';
      document.getElementById('fill').style.width = percent.toFixed(1) + '%';
      const totalLineStr = linesTotal ? ` / ${linesTotal.toLocaleString()} lines` : '';
      const fileLinesTxt = fileLinesTotal > 0 ? `file ${fileLinesDone.toLocaleString()} / ${fileLinesTotal.toLocaleString()} lines (${filePercent.toFixed(1)}%)` : `file ${fileLinesDone.toLocaleString()} lines`;
      let overallTxt = '';
      if (linesTotal > 0) overallTxt = `${percent.toFixed(1)}% — overall ${lines.toLocaleString()} / ${linesTotal.toLocaleString()} lines — files ${filesDone}/${filesTotal}`; else overallTxt = `${percent.toFixed(1)}% — ${lines.toLocaleString()} lines${totalLineStr} — files ${filesDone}/${filesTotal}`;
      if (fileLinesTxt) overallTxt += ` | ${fileLinesTxt}`;
      document.getElementById('txt').textContent = overallTxt;
      const el = document.getElementById('curr');
      if (el){ const base = curr.replaceAll('\\\\','/'); const name = base.includes('/') ? base.split('/').pop() : base; el.textContent = name || '(preparing…)'; el.title = curr || ''; }
      const ep = document.getElementById('currpct'); if (ep) ep.textContent = filePercent ? `(${filePercent.toFixed(1)}%)` : '';
      if (st === 'done') {
        const limParam = encodeURIComponent(limitRaw);
        const limPart = `&limit=${limParam}`;
        window.location.href = `{{ url_for('report_home') }}?token=${token}` + (limitRaw !== '' ? limPart : '&limit=none');
        return;
      }
      if (st === 'error') { document.getElementById('txt').textContent = 'Error: ' + (data.error || 'unknown'); }
    }
    async function poll() {
      if (sseActive) return; // SSE supersedes polling
      try {
        const res = await fetch(`{{ url_for('report_status', token='__TOK__') }}`.replace('__TOK__', token), {cache: 'no-store'});
        if (!res.ok) throw new Error('status ' + res.status);
        const data = await res.json();
        applyProgressData(data);
  // Update separate total line indicators (retained from polling path)
  try {
    const ot = document.getElementById('overall_total_lines');
    if (ot) {
      if (linesTotal > 0) ot.textContent = `overall total lines: ${linesTotal.toLocaleString()}`;
      else ot.textContent = '';
    }
    const cft = document.getElementById('current_file_total_lines');
    if (cft) {
      if (fileLinesTotal > 0) cft.textContent = `current file total lines: ${fileLinesTotal.toLocaleString()}`;
      else cft.textContent = '';
    }
  } catch (e3) { /* ignore */ }
  // Establish start time once progress moves
  if ((percent > 0 || lines > 0) && startTimeMs == null) {
    startTimeMs = Date.now();
  }
  // Compute overall ETA using lines if total known, else percent
  let overallEtaTxt = '';
  if (startTimeMs != null) {
    const elapsedSec = (Date.now() - startTimeMs) / 1000.0;
    let remainingSec = null;
    if (linesTotal > 0 && lines > 0) {
      const rate = lines / elapsedSec; // lines per second
      if (rate > 0) remainingSec = (linesTotal - lines) / rate;
    } else if (percent > 0) {
      const rateP = percent / elapsedSec; // percent per second
      if (rateP > 0) remainingSec = (100 - percent) / rateP;
    }
    if (remainingSec != null) {
      // Simple smoothing: blend with previous ETA if available
      if (lastEtaSeconds != null) {
        remainingSec = 0.5 * remainingSec + 0.5 * lastEtaSeconds;
      }
      lastEtaSeconds = remainingSec;
  overallEtaTxt = 'overall ETA ' + fmtEta(remainingSec);
    }
  }
  document.getElementById('txt').textContent = overallTxt;
  // (per-file ETA combined later after its computation)
        // Update current file line explicitly (with basename + tooltip)
        try {
          const el = document.getElementById('curr');
          if (el) {
            const base = curr.replaceAll('\\\\','/');
            const name = base.includes('/') ? base.split('/').pop() : base;
            el.textContent = name || '(preparing…)';
            el.title = curr || '';
            // Detect file change to reset per-file ETA baseline
            if (curr && curr !== currentFilePath) {
              currentFilePath = curr;
              currentFileStartTimeMs = Date.now();
              currentFileStartLines = fileLinesDone;
              currentFileStartBytes = Number(p.file_bytes_done || 0);
              lastFileEtaSeconds = null;
            }
          }
          const ep = document.getElementById('currpct');
          if (ep) {
            ep.textContent = filePercent ? `(${filePercent.toFixed(1)}%)` : '';
            // Remove byte debug attributes since we now only surface line metrics
            ep.removeAttribute('data-file-bytes-done');
            ep.removeAttribute('data-file-bytes-total');
          }
          // Compute per-file ETA
          try {
            let fileEtaTxt = '';
            if (currentFileStartTimeMs != null && filePercent > 0 && (fileLinesTotal > 0 || Number(p.file_bytes_total||0) > 0)) {
              const elapsedFileSec = (Date.now() - currentFileStartTimeMs) / 1000.0;
              let remainingFileSec = null;
              if (fileLinesTotal > 0 && fileLinesDone > currentFileStartLines) {
                const processed = fileLinesDone - currentFileStartLines;
                const rate = processed / elapsedFileSec; // lines/sec
                if (rate > 0) remainingFileSec = (fileLinesTotal - fileLinesDone) / rate;
              } else {
                const fbTotal = Number(p.file_bytes_total || 0);
                const fbDone = Number(p.file_bytes_done || 0);
                if (fbTotal > 0 && fbDone > currentFileStartBytes) {
                  const processedB = fbDone - currentFileStartBytes;
                  const rateB = processedB / elapsedFileSec; // bytes/sec
                  if (rateB > 0) remainingFileSec = (fbTotal - fbDone) / rateB;
                }
              }
              if (remainingFileSec != null) {
                if (lastFileEtaSeconds != null) {
                  remainingFileSec = 0.5 * remainingFileSec + 0.5 * lastFileEtaSeconds;
                }
                lastFileEtaSeconds = remainingFileSec;
                fileEtaTxt = 'file ETA ' + fmtEta(remainingFileSec);
              }
            }
            fileEtaDisplay = fileEtaTxt;
          } catch (e2) { /* ignore */ }
        } catch (e) { /* noop */ }
        // Update unified ETA line (overall + per-file if present)
        try {
          const etaEl = document.getElementById('eta');
          if (etaEl) {
            const parts = [];
            if (overallEtaTxt) parts.push(overallEtaTxt);
            if (fileEtaDisplay) parts.push(fileEtaDisplay);
            etaEl.textContent = parts.join(' | ');
          }
        } catch (_) { /* ignore */ }
        return; // early exit after applying data
      } catch (e) {
        // transient errors are okay; keep polling
      }
      setTimeout(poll, 800);
    }
  async function refreshTable(forceImmediate=false) {
      try {
    const bust = Date.now();
  const baseUrl = `{{ url_for('report_status_fdvtable', token='__TOK__') }}`.replace('__TOK__', token);
  // Include limit parameter so interim PASS/FAIL reflects selected mode
  const limQ = (limitRaw && limitRaw.toLowerCase() !== 'none') ? `&limit=${encodeURIComponent(limitRaw)}` : '&limit=none';
  const res = await fetch(baseUrl + `?t=${bust}` + limQ, {cache: 'no-store'});
        if (res.ok) {
          const html = await res.text();
          if (html && html !== lastTableHtml) {
            document.getElementById('fdvtable').innerHTML = html;
            lastTableHtml = html;
          }
        }
      } catch (e) { /* ignore */ }
      if (!forceImmediate) setTimeout(refreshTable, 1500);
    }
  if (!startSSE()) { poll(); }
    refreshTable();
    // Initialize limit input & mode display
  (function initLimitBox(){ try { const inp = document.getElementById('limitProgress'); if (inp) { inp.value = (limitRaw || 'default'); } updateLimitModeDisplay(); } catch(e){} })();
  </script>
</body>
</html>
